/**
 * Malware Scanner
 * Advanced malware detection and scanning capabilities
 */

const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
const securityAuditLogger = require('./SecurityAuditLogger');
const configManager = require('./SecureConfigManager');

class MalwareScanner {
  constructor() {
    this.scannerEnabled = configManager.getBoolean('MALWARE_SCANNER_ENABLED', true);
    this.quarantineDir = './uploads/quarantine';
    this.signatureDatabase = this.initializeSignatureDatabase();
    this.behaviorPatterns = this.initializeBehaviorPatterns();
    this.suspiciousStrings = this.initializeSuspiciousStrings();
    
    // Scanning statistics
    this.stats = {
      totalScans: 0,
      threatsDetected: 0,
      filesQuarantined: 0,
      lastScanTime: null
    };
  }

  /**
   * Initialize malware signature database
   */
  initializeSignatureDatabase() {
    return {
      // Known malware signatures (simplified examples)
      'eicar_test': '58354f2150254041505b345c50585d35344e4e7b24454943415253544e44415244414e544956495255535445535446494c452124482b482a',
      
      // Suspicious executable patterns
      'pe_header': '4d5a', // PE header
      'elf_header': '7f454c46', // ELF header
      'mach_o': 'feedface', // Mach-O header
      'java_class': 'cafebabe', // Java class file
      
      // Script patterns
      'php_tag': '3c3f706870', // <?php
      'asp_tag': '3c25', // <%
      'jsp_tag': '3c254020', // <%@
      
      // Archive bombs patterns
      'zip_bomb_marker': '504b0304140000000800', // Compressed ZIP with high ratio
      
      // Ransomware patterns
      'crypto_locker': '2e656e637279707465642e', // .encrypted.
      'wannacry_marker': '576e6e614372792e', // WnnaCry.
      
      // Trojan patterns
      'backdoor_marker': '6261636b646f6f72', // backdoor
      'keylogger_marker': '6b65796c6f67676572', // keylogger
      
      // Rootkit patterns
      'rootkit_marker': '726f6f746b6974', // rootkit
      'stealth_marker': '737465616c7468' // stealth
    };
  }

  /**
   * Initialize behavior pattern detection
   */
  initializeBehaviorPatterns() {
    return [
      // Network communication patterns
      {
        name: 'suspicious_network_call',
        pattern: /(curl|wget|nc|netcat|telnet)\s+[\w\.\-]+/gi,
        severity: 'high',
        description: 'Suspicious network communication'
      },
      
      // File system manipulation
      {
        name: 'file_manipulation',
        pattern: /(rm\s+-rf|del\s+\/[sq]|format\s+c:)/gi,
        severity: 'critical',
        description: 'Destructive file system operations'
      },
      
      // Registry manipulation (Windows)
      {
        name: 'registry_manipulation',
        pattern: /(regedit|reg\s+add|reg\s+delete)/gi,
        severity: 'high',
        description: 'Windows registry manipulation'
      },
      
      // Process injection
      {
        name: 'process_injection',
        pattern: /(CreateRemoteThread|WriteProcessMemory|VirtualAllocEx)/gi,
        severity: 'critical',
        description: 'Process injection techniques'
      },
      
      // Cryptographic operations (potential ransomware)
      {
        name: 'crypto_operations',
        pattern: /(AES|RSA|encrypt|decrypt|cipher).*\.(lock|crypt|encrypted)/gi,
        severity: 'high',
        description: 'Suspicious cryptographic operations'
      },
      
      // Anti-analysis techniques
      {
        name: 'anti_analysis',
        pattern: /(IsDebuggerPresent|CheckRemoteDebuggerPresent|GetTickCount)/gi,
        severity: 'medium',
        description: 'Anti-analysis techniques'
      },
      
      // Privilege escalation
      {
        name: 'privilege_escalation',
        pattern: /(sudo|runas|UAC|SeDebugPrivilege)/gi,
        severity: 'high',
        description: 'Privilege escalation attempts'
      }
    ];
  }

  /**
   * Initialize suspicious strings database
   */
  initializeSuspiciousStrings() {
    return [
      // Command execution
      'eval(', 'exec(', 'system(', 'shell_exec(', 'passthru(',
      'popen(', 'proc_open(', 'file_get_contents(',
      
      // SQL injection
      'UNION SELECT', 'DROP TABLE', 'DELETE FROM', 'INSERT INTO',
      'UPDATE SET', 'CREATE TABLE', 'ALTER TABLE',
      
      // XSS patterns
      '<script>', '</script>', 'javascript:', 'vbscript:',
      'onload=', 'onerror=', 'onclick=', 'onmouseover=',
      
      // File inclusion
      'include(', 'require(', 'include_once(', 'require_once(',
      
      // Obfuscation markers
      'base64_decode(', 'gzinflate(', 'str_rot13(', 'chr(',
      
      // Malware families
      'wannacry', 'petya', 'locky', 'cryptolocker', 'ransomware',
      'backdoor', 'trojan', 'keylogger', 'rootkit', 'botnet',
      
      // Suspicious domains/IPs
      '.onion', 'bit.ly', 'tinyurl.com', 'pastebin.com',
      
      // Cryptocurrency
      'bitcoin', 'monero', 'cryptocurrency', 'mining', 'wallet'
    ];
  }

  /**
   * Scan file for malware
   */
  async scanFile(fileBuffer, fileName, options = {}) {
    const scanId = this.generateScanId();
    const startTime = Date.now();
    
    try {
      this.stats.totalScans++;
      this.stats.lastScanTime = new Date().toISOString();

      const scanResult = {
        scanId,
        fileName,
        fileSize: fileBuffer.length,
        scanTime: startTime,
        threats: [],
        severity: 'clean',
        quarantined: false,
        details: {}
      };

      // Skip scanning if disabled
      if (!this.scannerEnabled) {
        scanResult.skipped = true;
        scanResult.reason = 'Scanner disabled';
        return scanResult;
      }

      // Signature-based scanning
      const signatureResults = await this.scanSignatures(fileBuffer);
      if (signatureResults.threats.length > 0) {
        scanResult.threats.push(...signatureResults.threats);
        scanResult.severity = this.calculateMaxSeverity(scanResult.threats);
      }

      // Behavior pattern analysis
      const behaviorResults = await this.scanBehaviorPatterns(fileBuffer);
      if (behaviorResults.threats.length > 0) {
        scanResult.threats.push(...behaviorResults.threats);
        scanResult.severity = this.calculateMaxSeverity(scanResult.threats);
      }

      // Suspicious string detection
      const stringResults = await this.scanSuspiciousStrings(fileBuffer);
      if (stringResults.threats.length > 0) {
        scanResult.threats.push(...stringResults.threats);
        scanResult.severity = this.calculateMaxSeverity(scanResult.threats);
      }

      // Heuristic analysis
      const heuristicResults = await this.heuristicAnalysis(fileBuffer, fileName);
      if (heuristicResults.threats.length > 0) {
        scanResult.threats.push(...heuristicResults.threats);
        scanResult.severity = this.calculateMaxSeverity(scanResult.threats);
      }

      // Determine if file should be quarantined
      if (scanResult.severity === 'critical' || scanResult.severity === 'high') {
        scanResult.quarantined = true;
        await this.quarantineFile(fileBuffer, scanId, fileName, scanResult);
        this.stats.filesQuarantined++;
      }

      // Update threat statistics
      if (scanResult.threats.length > 0) {
        this.stats.threatsDetected++;
      }

      // Log scan results
      await this.logScanResult(scanResult, options.req);

      scanResult.scanDuration = Date.now() - startTime;
      return scanResult;

    } catch (error) {
      console.error('Malware scan error:', error);
      
      await securityAuditLogger.logEvent({
        type: 'malware_scan_error',
        severity: securityAuditLogger.severityLevels.HIGH,
        details: {
          scanId,
          fileName,
          error: error.message
        }
      });

      return {
        scanId,
        fileName,
        error: error.message,
        scanDuration: Date.now() - startTime
      };
    }
  }

  /**
   * Scan for known malware signatures
   */
  async scanSignatures(fileBuffer) {
    const threats = [];
    const fileHex = fileBuffer.toString('hex').toLowerCase();

    for (const [name, signature] of Object.entries(this.signatureDatabase)) {
      if (fileHex.includes(signature.toLowerCase())) {
        threats.push({
          type: 'signature',
          name: name,
          severity: this.getSignatureSeverity(name),
          description: `Known malware signature detected: ${name}`
        });
      }
    }

    return { threats };
  }

  /**
   * Scan for suspicious behavior patterns
   */
  async scanBehaviorPatterns(fileBuffer) {
    const threats = [];
    const fileContent = fileBuffer.toString('utf8', 0, Math.min(fileBuffer.length, 1024 * 1024)); // First 1MB

    for (const pattern of this.behaviorPatterns) {
      const matches = fileContent.match(pattern.pattern);
      if (matches) {
        threats.push({
          type: 'behavior',
          name: pattern.name,
          severity: pattern.severity,
          description: pattern.description,
          matches: matches.slice(0, 5) // Limit matches for logging
        });
      }
    }

    return { threats };
  }

  /**
   * Scan for suspicious strings
   */
  async scanSuspiciousStrings(fileBuffer) {
    const threats = [];
    const fileContent = fileBuffer.toString('utf8', 0, Math.min(fileBuffer.length, 1024 * 1024)).toLowerCase();

    const suspiciousFound = [];
    for (const suspiciousString of this.suspiciousStrings) {
      if (fileContent.includes(suspiciousString.toLowerCase())) {
        suspiciousFound.push(suspiciousString);
      }
    }

    if (suspiciousFound.length > 0) {
      const severity = suspiciousFound.length > 5 ? 'high' : 'medium';
      threats.push({
        type: 'suspicious_strings',
        name: 'suspicious_content',
        severity: severity,
        description: `Suspicious strings detected: ${suspiciousFound.slice(0, 10).join(', ')}`,
        count: suspiciousFound.length
      });
    }

    return { threats };
  }

  /**
   * Heuristic analysis for unknown threats
   */
  async heuristicAnalysis(fileBuffer, fileName) {
    const threats = [];
    const fileContent = fileBuffer.toString('utf8', 0, Math.min(fileBuffer.length, 65536));

    // Check entropy (high entropy might indicate encryption/packing)
    const entropy = this.calculateEntropy(fileBuffer);
    if (entropy > 7.5) {
      threats.push({
        type: 'heuristic',
        name: 'high_entropy',
        severity: 'medium',
        description: `High entropy detected (${entropy.toFixed(2)}), possible packed/encrypted content`
      });
    }

    // Check for multiple file format headers (polyglot)
    const headerCount = this.countFileHeaders(fileBuffer);
    if (headerCount > 1) {
      threats.push({
        type: 'heuristic',
        name: 'polyglot_file',
        severity: 'high',
        description: `Multiple file format headers detected (${headerCount})`
      });
    }

    // Check for suspicious file size patterns
    if (fileBuffer.length > 0 && fileBuffer.length < 100) {
      const uniqueBytes = new Set(fileBuffer).size;
      if (uniqueBytes < 5) {
        threats.push({
          type: 'heuristic',
          name: 'suspicious_pattern',
          severity: 'medium',
          description: 'File contains repetitive byte patterns'
        });
      }
    }

    // Check for embedded executables
    if (this.containsEmbeddedExecutable(fileBuffer)) {
      threats.push({
        type: 'heuristic',
        name: 'embedded_executable',
        severity: 'high',
        description: 'File contains embedded executable code'
      });
    }

    return { threats };
  }

  /**
   * Calculate file entropy
   */
  calculateEntropy(buffer) {
    const frequencies = new Array(256).fill(0);
    
    for (let i = 0; i < buffer.length; i++) {
      frequencies[buffer[i]]++;
    }
    
    let entropy = 0;
    for (let i = 0; i < 256; i++) {
      if (frequencies[i] > 0) {
        const probability = frequencies[i] / buffer.length;
        entropy -= probability * Math.log2(probability);
      }
    }
    
    return entropy;
  }

  /**
   * Count file format headers
   */
  countFileHeaders(buffer) {
    const headers = ['4d5a', '7f454c46', '89504e47', 'ffd8ffe0', '25504446', '504b0304'];
    const bufferHex = buffer.slice(0, 64).toString('hex').toLowerCase();
    
    return headers.filter(header => bufferHex.includes(header)).length;
  }

  /**
   * Check for embedded executables
   */
  containsEmbeddedExecutable(buffer) {
    const executableSignatures = ['4d5a', '7f454c46', 'cafebabe'];
    const bufferHex = buffer.toString('hex').toLowerCase();
    
    // Look for signatures not at the beginning of the file
    for (const sig of executableSignatures) {
      const index = bufferHex.indexOf(sig);
      if (index > 0) { // Found signature not at the beginning
        return true;
      }
    }
    
    return false;
  }

  /**
   * Get severity for signature detection
   */
  getSignatureSeverity(signatureName) {
    const criticalSignatures = ['eicar_test', 'wannacry_marker', 'crypto_locker'];
    const highSignatures = ['backdoor_marker', 'keylogger_marker', 'rootkit_marker'];
    
    if (criticalSignatures.includes(signatureName)) return 'critical';
    if (highSignatures.includes(signatureName)) return 'high';
    return 'medium';
  }

  /**
   * Calculate maximum severity from threats
   */
  calculateMaxSeverity(threats) {
    const severityLevels = { 'clean': 0, 'low': 1, 'medium': 2, 'high': 3, 'critical': 4 };
    let maxSeverity = 'clean';
    
    for (const threat of threats) {
      if (severityLevels[threat.severity] > severityLevels[maxSeverity]) {
        maxSeverity = threat.severity;
      }
    }
    
    return maxSeverity;
  }

  /**
   * Quarantine malicious file
   */
  async quarantineFile(fileBuffer, scanId, fileName, scanResult) {
    try {
      const quarantinePath = path.join(this.quarantineDir, `${scanId}.malware`);
      await fs.writeFile(quarantinePath, fileBuffer);
      
      const reportPath = path.join(this.quarantineDir, `${scanId}.scan-report.json`);
      const report = {
        scanId,
        fileName,
        scanResult,
        quarantineTime: new Date().toISOString(),
        fileHash: crypto.createHash('sha256').update(fileBuffer).digest('hex')
      };
      
      await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
      
      console.log(`ðŸ¦  [MALWARE-SCANNER] File quarantined: ${scanId} (${fileName})`);
    } catch (error) {
      console.error('Failed to quarantine malicious file:', error);
    }
  }

  /**
   * Log scan results
   */
  async logScanResult(scanResult, req = null) {
    const eventType = scanResult.threats.length > 0 ? 'malware_detected' : 'malware_scan_clean';
    const severity = scanResult.threats.length > 0 ? scanResult.severity : 'low';
    
    await securityAuditLogger.logEvent({
      type: eventType,
      severity: securityAuditLogger.severityLevels[severity.toUpperCase()],
      userId: req?.user?.userId || null,
      ipAddress: req?.headers?.['x-forwarded-for'] || req?.connection?.remoteAddress,
      userAgent: req?.headers?.['user-agent'],
      details: {
        scanId: scanResult.scanId,
        fileName: scanResult.fileName,
        fileSize: scanResult.fileSize,
        threatsFound: scanResult.threats.length,
        threats: scanResult.threats,
        quarantined: scanResult.quarantined,
        scanDuration: scanResult.scanDuration
      },
      threats: scanResult.threats.map(t => t.name)
    });
  }

  /**
   * Generate unique scan ID
   */
  generateScanId() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `scan_${timestamp}_${random}`;
  }

  /**
   * Get scanning statistics
   */
  getStatistics() {
    return {
      ...this.stats,
      scannerEnabled: this.scannerEnabled,
      signatureCount: Object.keys(this.signatureDatabase).length,
      behaviorPatternCount: this.behaviorPatterns.length,
      suspiciousStringCount: this.suspiciousStrings.length
    };
  }

  /**
   * Update malware signatures (for future integration with threat intelligence)
   */
  async updateSignatures(newSignatures) {
    try {
      this.signatureDatabase = { ...this.signatureDatabase, ...newSignatures };
      
      await securityAuditLogger.logEvent({
        type: 'malware_signatures_updated',
        severity: securityAuditLogger.severityLevels.LOW,
        details: {
          newSignatureCount: Object.keys(newSignatures).length,
          totalSignatures: Object.keys(this.signatureDatabase).length
        }
      });
      
      return { success: true, updatedCount: Object.keys(newSignatures).length };
    } catch (error) {
      console.error('Failed to update malware signatures:', error);
      return { success: false, error: error.message };
    }
  }
}

module.exports = MalwareScanner;